---
title: "Python"
output:
  pdf_document:
    latex_engine: pdflatex # usa pdflatex
    number_sections: yes # numera las secciones
    toc: true # escribe el índice
    toc_depth: 3 # profundidad del indice 3
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

\newpage

# VARIABLES AND SIMPLE DATA TYPES

+ Changing Case in a String with Methods

    ```{python}
    # Escribe la primera letra de cada palabra en mayúscula
    name = "ada lovelace"
    print(name.title())

    # Escribe toda la palabra en mayúsculas
    print(name.upper())

    # Escribe toda la palabra en minúsculas
    print(name.lower())
    ```

+ Using Variables in Strings

    ```{python}
    first_name = "ada"
    last_name = "lovelace"
    full_name = f"{first_name} {last_name}"
    print(full_name)
    ```
    
+ Adding Whitespace to Strings with Tabs or Newlines

    ```{python}
    print("Languages:\n\tPython\n\tC\n\tJavaScript")
    ```

+ Stripping Whitespace

    ```{python}
    favorite_language = ' python '
    favorite_language.rstrip()
    favorite_language.lstrip()
    favorite_language.strip()
    ```

+ Removing Prefixes

    ```{python}
    nostarch_url = 'https://nostarch.com'
    nostarch_url.removeprefix('https://')
    ```
    
+ Underscores in Numbers

    ```{python}
    universe_age = 14_000_000_000
    print(universe_age)
    ```
    
+ Multiple Assignment

    ```{python}
    x, y, z = 0, 0, 0
    ```

# INTRODUCING LISTS

```{python}
bicycles = ['trek', 'cannondale', 'redline', 'specialized']
print(bicycles)
```

+ Accessing Elements in a List

    ```{python}
    print(bicycles[0].title())
    ```
    
    Python has a special syntax for accessing the last element in a list. If you ask for the item at index -1, Python always returns the last item in the list:
    
    ```{python}
    print(bicycles[-1])
    ```

+ Using Individual Values from a List

    ```{python}
    message = f"My first bicycle was a {bicycles[0].title()}."
    print(message)
    ```

+ Modifying Elements in a List

    ```{python}
    motorcycles = ['honda', 'yamaha', 'suzuki']
    print(motorcycles)
    motorcycles[0] = 'ducati'
    print(motorcycles)
    ```

+ Adding Elements to a List

    ```{python}
    motorcycles = ['honda', 'yamaha', 'suzuki']
    print(motorcycles)
    motorcycles.append('ducati')
    print(motorcycles)
    ```
    
+ Inserting Elements into a List

    ```{python}
    motorcycles = ['honda', 'yamaha', 'suzuki']
    motorcycles.insert(0, 'ducati')
    print(motorcycles)
    ```

+ Removing an Item Using the del Statement

    ```{python}
    motorcycles = ['honda', 'yamaha', 'suzuki']
    print(motorcycles)
    del motorcycles[0]
    print(motorcycles)
    ```

+ Removing an Item Using the pop() Method

    ```{python}
    motorcycles = ['honda', 'yamaha', 'suzuki']
    print(motorcycles)
    popped_motorcycle = motorcycles.pop()
    print(motorcycles)
    print(popped_motorcycle)
    ```

+ Popping Items from Any Position in a List

    ```{python}
    motorcycles = ['honda', 'yamaha', 'suzuki']
    first_owned = motorcycles.pop(0)
    print(f"The first motorcycle I owned was a {first_owned.title()}.")
    ```

+ Removing an Item by Value

    ```{python}
    motorcycles = ['honda', 'yamaha', 'suzuki', 'ducati']
    print(motorcycles)
    motorcycles.remove('ducati')
    print(motorcycles)
    ```

+ Sorting a List Permanently with the sort() Method

    ```{python}
    cars = ['bmw', 'audi', 'toyota', 'subaru']
    cars.sort()
    print(cars)
    ```

+ Sorting a List Temporarily with the sorted() Function

    ```{python}
    cars = ['bmw', 'audi', 'toyota', 'subaru']
    print("Here is the original list:")
    print(cars)
    print("\nHere is the sorted list:")
    print(sorted(cars))
    print("\nHere is the original list again:")
    print(cars)
    ```
+ Printing a List in Reverse Order

    ```{python}
    cars = ['bmw', 'audi', 'toyota', 'subaru']
    print(cars)
    cars.reverse()
    print(cars)
    ```

+ Finding the Length of a List

    ```{python}
    cars = ['bmw', 'audi', 'toyota', 'subaru']
    len(cars)
    ```

# WORKING WITH LISTS

+ Looping Through an Entire List

    ```{python}
    magicians = ['alice', 'david', 'carolina']
    for magician in magicians:
      print(magician)
    ```

+ Using the range() Function

    ```{python}
    for value in range(1, 5):
      print(value)
    ```

+ Using range() to Make a List of Numbers

    ```{python}
    numbers = list(range(1, 6))
    print(numbers)
    
    even_numbers = list(range(2, 11, 2))
    print(even_numbers)
    
    squares = []
    for value in range(1,11):
      squares.append(value**2)
    print(squares)
    ```

+ Simple Statistics with a List of Numbers

    ```{python}
    digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
    min(digits)
    max(digits)
    sum(digits)
    ```

+ List Comprehensions

    ```{python}
    squares = [value**2 for value in range(1, 11)]
    print(squares)
    ```

+ Slicing a List

    ```{python}
    players = ['charles', 'martina', 'michael', 'florence', 'eli']
    print(players[0:3])
    
    print(players[:4])
    
    print(players[2:])
    
    # con el signo negativo cuenta desde el final
    print(players[-3:])
    ```

+ Looping Through a Slice

    ```{python}
    print("Here are the first three players on my team:")
    for player in players[:3]:
      print(player.title())
    ```

+ Copying a List

    ```{python}
    my_foods = ['pizza', 'falafel', 'carrot cake']
    friend_foods = my_foods[:]
    print("My favorite foods are:")
    print(my_foods)
    print("\nMy friend's favorite foods are:")
    print(friend_foods)
    ```

+ Defining a Tuple
    Las tuplas son como las listas, pero no se pueden modificar. Si queremos cambiar una tupla tenemos que redefinirla.

    ```{python}
    dimensions = (200, 50)
    print(dimensions[0])
    print(dimensions[1])
    ```

# IF STATEMENTS

+ A Simple Example

    ```{python}
    cars = ['audi', 'bmw', 'subaru', 'toyota']
    for car in cars:
      if car == 'bmw':
        print(car.upper())
      else:
        print(car.title())
    ```

+ Checking for Inequality

    ```{python}
    requested_topping = 'mushrooms'
    if requested_topping != 'anchovies':
      print("Hold the anchovies!")
    ```

+ Numerical Comparisons

    ```{python}
    answer = 17
    if answer != 42:
      print("That is not the correct answer. Please try again!")
    ```

+ Checking Whether a Value Is in a List

    ```{python}
    requested_toppings = ['mushrooms', 'onions', 'pineapple']
    'mushrooms' in requested_toppings
    'pepperoni' in requested_toppings
    ```

+ Checking Whether a Value Is Not in a List

    ```{python}
    banned_users = ['andrew', 'carolina', 'david']
    user = 'marie'
    if user not in banned_users:
      print(f"{user.title()}, you can post a response if you wish.")
    ```

+ Testing Multiple Conditions
    The if- elif- else block would stop running after only one test passes.
    
+ Using if Statements with Lists

    ```{python}
    requested_toppings = ['mushrooms', 'green peppers', 'extra cheese']
    for requested_topping in requested_toppings:
      print(f"Adding {requested_topping}.")
    print("\nFinished making your pizza!")
    ```
    
    ```{python}
    for requested_topping in requested_toppings:
      if requested_topping == 'green peppers':
        print("Sorry, we are out of green peppers right now.")
      else:
        print(f"Adding {requested_topping}.")
    print("\nFinished making your pizza!")
    ```

+ Checking That a List Is Not Empty

    ```{python}
    requested_toppings = []
    if requested_toppings:
      for requested_topping in requested_toppings:
        print(f"Adding {requested_topping}.")
      print("\nFinished making your pizza!")
    else:
      print("Are you sure you want a plain pizza?")
    ```

+ Using Multiple Lists

    ```{python}
    available_toppings = ['mushrooms', 'olives', 'green peppers',
    'pepperoni', 'pineapple', 'extra cheese']
    requested_toppings = ['mushrooms', 'french fries', 'extra cheese']
    for requested_topping in requested_toppings:
      if requested_topping in available_toppings:
        print(f"Adding {requested_topping}.")
      else:
        print(f"Sorry, we don't have {requested_topping}.")
    print("\nFinished making your pizza!")
    ```

# DICTIONARIES

```{python}
alien_0 = {'color': 'green', 'points': 5}
print(alien_0['color'])
print(alien_0['points'])
```

+ Adding New Key-Value Pairs

    ```{python}
    alien_0 = {'color': 'green', 'points': 5}
    print(alien_0)
    alien_0['x_position'] = 0
    alien_0['y_position'] = 25
    print(alien_0)
    ```

+ Starting with an Empty Dictionary

    ```{python}
    alien_0 = {}
    alien_0['color'] = 'green'
    alien_0['points'] = 5
    print(alien_0)
    ```

+ Modifying Values in a Dictionary

    ```{python}
    alien_0 = {'color': 'green'}
    print(f"The alien is {alien_0['color']}.")
    alien_0['color'] = 'yellow'
    print(f"The alien is now {alien_0['color']}.")
    ```

+ Removing Key-Value Pairs

    ```{python}
    alien_0 = {'color': 'green', 'points': 5}
    print(alien_0)
    del alien_0['points']
    print(alien_0)
    ```

+ Using get() to Access Values

    Using keys in square brackets to retrieve the value you’re interested in from a dictionary might cause one potential problem: if the key you ask for doesn’t exist, you’ll get an error.
    
    The get() method requires a key as a first argument. As a second optional argument, you can pass the value to be returned if the key doesn’t exist:

    ```{python}
    alien_0 = {'color': 'green', 'speed': 'slow'}
    point_value = alien_0.get('points', 'No point value assigned.')
    print(point_value)
    ```

+ Looping Through a Dictionary

    ```{python}
    user_0 = {
      'username': 'efermi',
      'first': 'enrico',
      'last': 'fermi',
    }
    
    for key, value in user_0.items():
      print(f"\nKey: {key}")
      print(f"Value: {value}")
    ```

+ Looping Through All the Keys in a Dictionary

    ```{python}
    favorite_languages = {
      'jen': 'python',
      'sarah': 'c',
      'edward': 'rust',
      'phil': 'python',
    }
    
    for name in favorite_languages.keys():
      print(name.title())
    ```
    
    Looping through the keys is actually the default behavior when looping through a dictionary, so this code would have exactly the same output if you wrote:
    
    ```{python}
    for name in favorite_languages:
      print(name.title())
    ```
    
    You can access the value associated with any key you care about inside the loop, by using the current key. Let’s print a message to a couple of friends about the languages they chose. We’ll loop through the names in the dictionary as we did previously, but when the name matches one of our friends, we’ll display a message about their favorite language:
    
    ```{python}
    friends = ['phil', 'sarah']
    for name in favorite_languages.keys():
      print(f"Hi {name.title()}.")

      if name in friends:
        language = favorite_languages[name].title()
        print(f"\t{name.title()}, I see you love {language}!")
    ```
    
    You can also use the keys() method to find out if a particular person was polled. This time, let’s find out if Erin took the poll:
    
    ```{python}
    if 'erin' not in favorite_languages.keys():
      print("Erin, please take our poll!")
    ```

+ Looping Through a Dictionary’s Keys in a Particular Order

    ```{python}
    for name in sorted(favorite_languages.keys()):
      print(f"{name.title()}, thank you for taking the poll.")
    ```

+ Looping Through All Values in a Dictionary

    ```{python}
    print("The following languages have been mentioned:")
    for language in favorite_languages.values():
      print(language.title())
    ```
    
    This approach pulls all the values from the dictionary without checking for repeats. This might work fine with a small number of values, but in a poll with a large number of respondents, it would result in a very repetitive list. To see each language chosen without repetition, we can use a set. A set is a collection in which each item must be unique:
    
    ```{python}
    print("The following languages have been mentioned:")
    for language in set(favorite_languages.values()):
      print(language.title())
    ```
    
    You can build a set directly using braces and separating the elements with commas:
    
    ```{python}
    languages = {'python', 'rust', 'python', 'c'}
    languages
    ```

+ A List of Dictionaries

    ```{python}
    alien_0 = {'color': 'green', 'points': 5}
    alien_1 = {'color': 'yellow', 'points': 10}
    alien_2 = {'color': 'red', 'points': 15}
    aliens = [alien_0, alien_1, alien_2]
    for alien in aliens:
      print(alien)
    ```
    
    A more realistic example would involve more than three aliens with code that automatically generates each alien. In the following example, we use range() to create a fleet of 30 aliens:
    
    ```{python}
    # Make an empty list for storing aliens.
    aliens = []
    
    # Make 30 green aliens.
    for alien_number in range(30):
      new_alien = {'color': 'green', 'points': 5, 'speed': 'slow'}
      aliens.append(new_alien)
    
    # Show the first 5 aliens.
    for alien in aliens[:5]:
      print(alien)
    print("...")
    
    # Show how many aliens have been created.
    print(f"Total number of aliens: {len(aliens)}")
    ```
    
    We can use a for loop and an if statement to change the color of the aliens. For example, to change the first three aliens to yellow, medium-speed aliens worth 10 points each, we could do this:
    
    ```{python}
    # Make an empty list for storing aliens.
    aliens = []

    # Make 30 green aliens.
    for alien_number in range (30):
      new_alien = {'color': 'green', 'points': 5, 'speed': 'slow'}
      aliens.append(new_alien)

    for alien in aliens[:3]:
      if alien['color'] == 'green':
        alien['color'] = 'yellow'
        alien['speed'] = 'medium'
        alien['points'] = 10

    # Show the first 5 aliens.
    for alien in aliens[:5]:
      print(alien)
    print("...")
    ```

+ A List in a Dictionary

    ```{python}
    # Store information about a pizza being ordered.
    pizza = {
      'crust': 'thick',
      'toppings': ['mushrooms', 'extra cheese'],
    }

    # Summarize the order.
    print(f"You ordered a {pizza['crust']}-crust pizza "
      "with the following toppings:")
    
    for topping in pizza['toppings']:
      print(f"\t{topping}")
    ```
    
    You can nest a list inside a dictionary anytime you want more than one value to be associated with a single key in a dictionary.
    
    ```{python}
    favorite_languages = {
      'jen': ['python', 'rust'],
      'sarah': ['c'],
      'edward': ['rust', 'go'],
      'phil': ['python', 'haskell'],
    }

    for name, languages in favorite_languages.items():
      print(f"\n{name.title()}'s favorite languages are:")
      for language in languages:
        print(f"\t{language.title()}")
    ```

+ A Dictionary in a Dictionary

    ```{python}
    users = {
      'aeinstein': {
        'first': 'albert',
        'last': 'einstein',
        'location': 'princeton',
      },

      'mcurie': {
        'first': 'marie',
        'last': 'curie',
        'location': 'paris',
      },
    }

    for username, user_info in users.items():
      print(f"\nUsername: {username}")
      full_name = f"{user_info['first']} {user_info['last']}"
      location = user_info['location']

      print(f"\tFull name: {full_name.title()}")
      print(f"\tLocation: {location.title()}")
    ```

# USER INPUT AND WHILE LOOPS

+ How the input() Function Works

    ```{python}
    # message = input("Tell me something, and I will repeat it back to you: ")
    # print(message)
    ```

+ Writing Clear Prompts

    ```{python}
    # name = input("Please enter your name: ")
    #print(f"\nHello, {name}!")
    ```
    
    Sometimes you’ll want to write a prompt that’s longer than one line.
    
    ```{python}
    # prompt = "If you share your name, we can personalize the messages you see."
    # prompt += "\nWhat is your first name? "
    
    # name = input(prompt)
    # print(f"\nHello, {name}!")
    ```

+ Using int() to Accept Numerical Input

    ```{python}
    # height = input("How tall are you, in inches? ")
    # height = int(height)

    # if height >= 48:
      # print("\nYou're tall enough to ride!")
    # else:
      # print("\nYou'll be able to ride when you're a little older.")
    ```
    
+ The Modulo Operator

    ```{python}
    # number = input("Enter a number, and I'll tell you if it's even or odd: ")
    # number = int(number)
    
    # if number % 2 == 0:
      # print(f"\nThe number {number} is even.")
    # else:
      # print(f"\nThe number {number} is odd.")
    ```

+ The while Loop in Action

    ```{python}
    current_number = 1
    while current_number <= 5:
      print(current_number)
      current_number += 1
    ```

+ Letting the User Choose When to Quit

    ```{python}
    # prompt = "\nTell me something, and I will repeat it back to you:"
    # prompt += "\nEnter 'quit' to end the program. "

    # message = ""
    # while message != 'quit':
      # message = input(prompt)
      
      # if message != 'quit':
        # print(message)
    ```

+ Using a Flag

    ```{python}
    # active = True
    # while active:
      # message = input(prompt)
      
      # if message == 'quit':
        # active = False
      # else:
        #print(message)
    ```
    
+ Using break to Exit a Loop

    ```{python}
    # prompt = "\nPlease enter the name of a city you have visited:"
    # prompt += "\n(Enter 'quit' when you are finished.) "
    
    # while True:
      # city = input(prompt)
      
      # if city == 'quit':
        # break
      # else:
        # print(f"I'd love to go to {city.title()}!")
    ```
    
+ Using continue in a Loop

    ```{python}
    current_number = 0
    while current_number < 10:
      current_number += 1
      if current_number % 2 == 0:
        continue
      print(current_number)
    ```

+ Using a while Loop with Lists and Dictionaries
+ Moving Items from One List to Another

    ```{python}
    # Start with users that need to be verified,
    # and an empty list to hold confirmed users.
    unconfirmed_users = ['alice', 'brian', 'candace']
    confirmed_users = []

    # Verify each user until there are no more unconfirmed users.
    # Move each verified user into the list of confirmed users.
    while unconfirmed_users:
      current_user = unconfirmed_users.pop()

      print(f"Verifying user: {current_user.title()}")
      confirmed_users.append(current_user)

    # Display all confirmed users.
    print("\nThe following users have been confirmed:")
    for confirmed_user in confirmed_users:
      print(confirmed_user.title())
    ```

+ Removing All Instances of Specific Values from a List

    ```{python}
    pets = ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']
    print(pets)
    
    while 'cat' in pets:
      pets.remove('cat')
    
    print(pets)
    ```

+ Filling a Dictionary with User Input

    ```{python}
    # responses = {}
    # # Set a flag to indicate that polling is active.
    # polling_active = True

    # while polling_active:
      # # Prompt for the person's name and response.
      # name = input("\nWhat is your name? ")
      # response = input("Which mountain would you like to climb someday? ")

      # # Store the response in the dictionary.
      # responses[name] = response

      # # Find out if anyone else is going to take the poll.
      # repeat = input("Would you like to let another person respond? (yes/ no) ")
      # if repeat == 'no':
        # polling_active = False

    # # Polling is complete. Show the results.
    # print("\n--- Poll Results ---")
    # for name, response in responses.items():
      # print(f"{name} would like to climb {response}.")
    ```
    
# FUNCTIONS

+ Defining a Function

    ```{python}
    def greet_user():
      """Display a simple greeting."""
      print("Hello!")
    
    greet_user()
    ```

+ Passing Information to a Function

    ```{python}
    def greet_user(username):
      """Display a simple greeting."""
      print(f"Hello, {username.title()}!")
    
    greet_user('jesse')
    ```

+ Passing Arguments

    ```{python}
    def describe_pet(animal_type, pet_name):
      """Display information about a pet."""
      print(f"\nI have a {animal_type}.")
      print(f"My {animal_type}'s name is {pet_name.title()}.")
    
    describe_pet('hamster', 'harry')
    ```

+ Keyword Arguments

    ```{python}
    def describe_pet(animal_type, pet_name):
      """Display information about a pet."""
      print(f"\nI have a {animal_type}.")
      print(f"My {animal_type}'s name is {pet_name.title()}.")

    describe_pet(animal_type='hamster', pet_name='harry')
    ```

+ Default Values

    Note that the order of the parameters in the function definition had to be changed. Because the default value makes it unnecessary to specify a type of animal as an argument, the only argument left in the function call is the pet’s name. Python still interprets this as a positional argument, so if the function is called with just a pet’s name, that argument will match up with the first parameter listed in the function’s definition. This is the reason the first parameter needs to be pet_name.

    ```{python}
    def describe_pet(pet_name, animal_type='dog'):
      """Display information about a pet."""
      print(f"\nI have a {animal_type}.")
      print(f"My {animal_type}'s name is {pet_name.title()}.")
      
    describe_pet(pet_name='willie')
    # También se puede hacer así:
    describe_pet('willie')
    ```

+ Return Values

    ```{python}
    def get_formatted_name(first_name, last_name):
      """Return a full name, neatly formatted."""
      full_name = f"{first_name} {last_name}"
      return full_name.title()
    
    musician = get_formatted_name('jimi', 'hendrix')
    print(musician)
    ```

+ Making an Argument Optional

    ```{python}
    def get_formatted_name(first_name, last_name, middle_name=''):
      """Return a full name, neatly formatted."""
      if middle_name:
        full_name = f"{first_name} {middle_name} {last_name}"
      else:
        full_name = f"{first_name} {last_name}"
      return full_name.title()

    musician = get_formatted_name('jimi', 'hendrix')
    print(musician)
    musician = get_formatted_name('john', 'hooker', 'lee')
    print(musician)
    ```

+ Returning a Dictionary

    ```{python}
    def build_person(first_name, last_name):
      """Return a dictionary of information about a person."""
      person = {'first': first_name, 'last': last_name}
      return person

    musician = build_person('jimi', 'hendrix')
    print(musician)
    ```
    
    You can easily extend this function to accept optional values like a middle name, an age, an occupation, or any other information you want to store about a person. For example, the following change allows you to store a person’s age as well:
    
    ```{python}
    def build_person(first_name, last_name, age=None):
      """Return a dictionary of information about a person."""
      person = {'first': first_name, 'last': last_name}
      if age:
        person['age'] = age
      return person

    musician = build_person('jimi', 'hendrix', age=27)
    print(musician)
    ```
    
+ Using a Function with a while Loop

    ```{python}
    # def get_formatted_name(first_name, last_name):
      # """Return a full name, neatly formatted."""
      # full_name = f"{first_name} {last_name}"
      # return full_name.title()

    # while True:
      # print("\nPlease tell me your name:")
      # print("(enter 'q' at any time to quit)")

      # f_name = input("First name: ")
      # if f_name == 'q':
        # break

      # l_name = input("Last name: ")
      # if l_name == 'q':
        # break

      # formatted_name = get_formatted_name(f_name, l_name)
      # print(f"\nHello, {formatted_name}!")
    ```

+ Passing a List

    ```{python}
    def greet_users(names):
      """Print a simple greeting to each user in the list."""
      for name in names:
        msg = f"Hello, {name.title()}!"
        print(msg)
    
    usernames = ['hannah', 'ty', 'margot']
    greet_users(usernames)
    ```

+ Modifying a List in a Function

    ```{python}
    # Start with some designs that need to be printed.
    unprinted_designs = ['phone case', 'robot pendant', 'dodecahedron']
    completed_models = []
    
    # Simulate printing each design, until none are left.
    # Move each design to completed_models after printing.
    while unprinted_designs:
      current_design = unprinted_designs.pop()
      print(f"Printing model: {current_design}")
      completed_models.append(current_design)

    # Display all completed models.
    print("\nThe following models have been printed:")
    for completed_model in completed_models:
      print(completed_model)
    ```
    
    We can reorganize this code by writing two functions, each of which does one specific job. Most of the code won’t change; we’re just structuring it more carefully. The first function will handle printing the designs, and the second will summarize the prints that have been made:
    
    ```{python}
    def print_models(unprinted_designs, completed_models):
      """
      Simulate printing each design, until none are left.
      Move each design to completed_models after printing.
      """

      while unprinted_designs:
        current_design = unprinted_designs.pop()
        print(f"Printing model: {current_design}")
        completed_models.append(current_design)

    def show_completed_models(completed_models):
      """Show all the models that were printed."""
      print("\nThe following models have been printed:")
      for completed_model in completed_models:
        print(completed_model)
        
    unprinted_designs = ['phone case', 'robot pendant', 'dodecahedron']
    completed_models = []

    print_models(unprinted_designs, completed_models)
    show_completed_models(completed_models)
    ```

+ Preventing a Function from Modifying a List

    Sometimes you’ll want to prevent a function from modifying a list. For example, say that you start with a list of unprinted designs and write a function to move them to a list of completed models, as in the previous example. You may decide that even though you’ve printed all the designs, you want to keep the original list of unprinted designs for your records. But because you moved all the design names out of unprinted_designs, the list is now empty, and the empty list is the only version you have; the original is gone. In this case, you can address this issue by passing the function a copy of the list, not the original. Any changes the function makes to the list will affect only the copy, leaving the original list intact.
    
    You can send a copy of a list to a function like this:
    
    ```{python}
    # function_name(list_name[:])
    ```
    
    The slice notation [:] makes a copy of the list to send to the function. If we didn’t want to empty the list of unprinted designs in printing_models.py, we could call print_models() like this:
    
    ```{python}
    # print_models(unprinted_designs[:], completed_models)
    ```

+ Passing an Arbitrary Number of Arguments

    ```{python}
    def make_pizza(*toppings):
      """Summarize the pizza we are about to make."""
      print("\nMaking a pizza with the following toppings:")
      for topping in toppings:
        print(f"- {topping}")
    
    make_pizza('pepperoni')
    make_pizza('mushrooms', 'green peppers', 'extra cheese')
    ```
    
+ Mixing Positional and Arbitrary Arguments

    If you want a function to accept several different kinds of arguments, the parameter that accepts an arbitrary number of arguments must be placed last in the function definition. Python matches positional and keyword arguments first and then collects any remaining arguments in the final parameter.
    
    For example, if the function needs to take in a size for the pizza, that parameter must come before the parameter *toppings:
    
    ```{python}
    def make_pizza(size, *toppings):
      """Summarize the pizza we are about to make."""
      print(f"\nMaking a {size}-inch pizza with the following toppings:")
      for topping in toppings:
        print(f"- {topping}")

    make_pizza(16, 'pepperoni')
    make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
    ```

+ Using Arbitrary Keyword Arguments

    Sometimes you’ll want to accept an arbitrary number of arguments, but you won’t know ahead of time what kind of information will be passed to the function. In this case, you can write functions that accept as many key-value pairs as the calling statement provides. One example involves building user profiles: you know you’ll get information about a user, but you’re not sure what kind of information you’ll receive. The function build_profile() in the following example always takes in a first and last name, but it accepts an arbitrary number of keyword arguments as well:

    ```{python}
    def build_profile(first, last, **user_info):
      """Build a dictionary containing everything we know about a user."""
      user_info['first_name'] = first
      user_info['last_name'] = last
      return user_info
    
    user_profile = build_profile('albert', 'einstein',
                                  location='princeton',
                                  field='physics')
    print(user_profile)
    ```
    
    The definition of build_profile() expects a first and last name, and then it allows the user to pass in as many name-value pairs as they want. The double asterisks before the parameter **user_info cause Python to create a dictionary called user_info containing all the extra name-value pairs the function receives. Within the function, you can access the key-value pairs in user_info just as you would for any dictionary.
    
    In the body of build_profile(), we add the first and last names to the user_info dictionary because we’ll always receive these two pieces of information from the user, and they haven’t been placed into the dictionary yet. Then we return the user_info dictionary to the function call line.

    We call build_profile(), passing it the first name 'albert', the last name 'einstein', and the two key-value pairs location='princeton' and field='physics'. We assign the returned profile to user_profile and print user_profile.

+ Storing Your Functions in Modules

+ Importing an Entire Module

    To start importing functions, we first need to create a module. A module is a file ending in .py that contains the code you want to import into your program.
    
    ```
    file pizza.py
    
    def make_pizza(size, *toppings):
      """Summarize the pizza we are about to make."""
      print(f"\nMaking a {size}-inch pizza with the following toppings:")
      for topping in toppings:
        print(f"- {topping}")
    ```
    
    Now we’ll make a separate file called making_pizzas.py in the same directory as pizza.py. This file imports the module we just created and then makes two calls to make_pizza():
    
    ```
    file making_pizzas.py
    
    import pizza
    
    pizza.make_pizza(16, 'pepperoni')
    pizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
    ```
    
    To call a function from an imported module, enter the name of the module you imported, pizza, followed by the name of the function, make_pizza(), separated by a dot.

+ Importing Specific Functions

    ```
    from module_name import function_name
    ```
    
    You can import as many functions as you want from a module by separating each function’s name with a comma:
    
    ```
    from module_name import function_0, function_1, function_2
    ```
    
    With this syntax, you don’t need to use the dot notation when you call a function. Because we’ve explicitly imported the function make_pizza() in the import statement, we can call it by name when we use the function.

+ Using as to Give a Function an Alias

    Here we give the function make_pizza() an alias, mp(), by importing make _pizza as mp. The as keyword renames a function using the alias you provide:
    
    ```
    from pizza import make_pizza as mp
    
    mp(16, 'pepperoni')
    mp(12, 'mushrooms', 'green peppers', 'extra cheese')
    ```
    
    The general syntax for providing an alias is:
    
    ```
    from module_name import function_name as fn
    ```
    
+ Using as to Give a Module an Alias

    ```
    import pizza as p

    p.make_pizza(16, 'pepperoni')
    p.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
    ```
    
    The general syntax for this approach is:
    
    ```
    import module_name as mn
    ```

+ Importing All Functions in a Module

    ```
    from pizza import *
    
    make_pizza(16, 'pepperoni')
    make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
    ```
    Because every function is imported, you can call each function by name without using the dot notation. However, it’s best not to use this approach when you’re working with larger modules that you didn’t write: if the module has a function name that matches an existing name in your project, you can get unexpected results.
    
+ Styling Functions

    If you specify a default value for a parameter, no spaces should be used on either side of the equal sign.
    
    ```
    def function_name(parameter_0, parameter_1='default value')
    ```
    
    The same convention should be used for keyword arguments in function calls:
    
    ```
    function_name(value_0, parameter_1='value')
    ```

    If a set of parameters causes a function’s definition to be longer than 79 characters, press ENTER after the opening parenthesis on the definition line. On the next line, press the TAB key twice to separate the list of arguments from the body of the function, which will only be indented one level.
    
    ```
    def function_name(
        parameter_0, parameter_1, parameter_2,
        parameter_3, parameter_4, parameter_5):
    function body...
    
# CLASSES

+ Creating the Dog Class

    ```{python}
    class Dog:
      """A simple attempt to model a dog."""
      
      def __init__(self, name, age):
        """Initialize name and age attributes."""
        self.name = name
        self.age = age
      
      def sit(self):
        """Simulate a dog sitting in response to a command."""
        print(f"{self.name} is now sitting.")

      def roll_over(self):
        """Simulate rolling over in response to a command."""
        print(f"{self.name} rolled over!")
    ```

+ Making an Instance from a Class

    ```{python}
    my_dog = Dog('Willie', 6)
    
    print(f"My dog's name is {my_dog.name}.")
    print(f"My dog is {my_dog.age} years old.")
    ```

+ Working with Classes and Instances

+ Setting a Default Value for an Attribute

    ```{python}
    class Car:

      def __init__(self, make, model, year):
        """Initialize attributes to describe a car."""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

      def get_descriptive_name(self):
        """Return a neatly formatted descriptive name."""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()
      
      def read_odometer(self):
        """Print a statement showing the car's mileage."""
        print(f"This car has {self.odometer_reading} miles on it.")

    my_new_car = Car('audi', 'a4', 2024)
    print(my_new_car.get_descriptive_name())
    my_new_car.read_odometer()
    ```

+ Modifying an Attribute’s Value Directly

    ```{python}
    my_new_car = Car('audi', 'a4', 2024)
    print(my_new_car.get_descriptive_name())

    my_new_car.odometer_reading = 23
    my_new_car.read_odometer()
    ```

+ Modifying an Attribute’s Value Through a Method

    ```{python}
    class Car:

      def __init__(self, make, model, year):
        """Initialize attributes to describe a car."""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

      def get_descriptive_name(self):
        """Return a neatly formatted descriptive name."""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()
      
      def read_odometer(self):
        """Print a statement showing the car's mileage."""
        print(f"This car has {self.odometer_reading} miles on it.")
        
      def update_odometer(self, mileage):
        """
        Set the odometer reading to the given value.
        Reject the change if it attemps to roll the odometer back.
        """
        if mileage >= self.odometer_reading:
          self.odometer_reading = mileage
        else:
          print("You can't roll back an odometer!")

    my_new_car = Car('audi', 'a4', 2024)
    print(my_new_car.get_descriptive_name())
    
    my_new_car.update_odometer(23)
    my_new_car.read_odometer()
    ```

+ Incrementing an Attribute’s Value Through a Method

    ```{python}
    class Car:

      def __init__(self, make, model, year):
        """Initialize attributes to describe a car."""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

      def get_descriptive_name(self):
        """Return a neatly formatted descriptive name."""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()
      
      def read_odometer(self):
        """Print a statement showing the car's mileage."""
        print(f"This car has {self.odometer_reading} miles on it.")
        
      def update_odometer(self, mileage):
        """
        Set the odometer reading to the given value.
        Reject the change if it attemps to roll the odometer back.
        """
        if mileage >= self.odometer_reading:
          self.odometer_reading = mileage
        else:
          print("You can't roll back an odometer!")
          
      def increment_odometer(self, miles):
        """Add the given amount to the odometer reading."""
        self.odometer_reading += miles
        
    my_user_car = Car('subaru', 'outback', 2019)
    print(my_user_car.get_descriptive_name())
    
    my_user_car.update_odometer(23_500)
    my_user_car.read_odometer()
    
    my_user_car.increment_odometer(100)
    my_user_car.read_odometer()
    ```

+ Inheritance

+ The \__init__() Method for a Child Class

    ```{python}
    class Car:
      """A simple attempt to represent a car."""
      
      def __init__(self, make, model, year):
        """Initialize attributes to describe a car."""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

      def get_descriptive_name(self):
        """Return a neatly formatted descriptive name."""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()

      def read_odometer(self):
        """Print a statement showing the car's mileage."""
        print(f"This car has {self.odometer_reading} miles on it.")

      def update_odometer(self, mileage):
        """Set the odometer reading to the given value."""
        if mileage >= self.odometer_reading:
          self.odometer_reading = mileage
        else:
          print("You can't roll back an odometer!")

      def increment_odometer(self, miles):
        """Add the given amount to the odometer reading."""
        self.odometer_reading += miles

    class ElectricCar(Car):
      """Represent aspects of a car, specific to electric vehicles."""

      def __init__(self, make, model, year):
        """Initialize attributes of the parent class."""
        super().__init__(make, model, year)

    my_leaf = ElectricCar('nissan', 'leaf', 2024)
    print(my_leaf.get_descriptive_name())
    ```

+ Defining Attributes and Methods for the Child Class

    ```{python}
    class ElectricCar(Car):
      """Represent aspects of a car, specific to electric vehicles."""

      def __init__(self, make, model, year):
        """
        Initialize attributes of the parent class.
        Then initialize attributes specific to an electric car.
        """

        super().__init__(make, model, year)
        self.battery_size = 40

      def describe_battery(self):
        """Print a statement describing the battery size."""
        print(f"This car has a {self.battery_size}-kWh battery.")

    my_leaf = ElectricCar('nissan', 'leaf', 2024)
    print(my_leaf.get_descriptive_name())
    my_leaf.describe_battery()
    ```

+ Overriding Methods from the Parent Class

    You define a method in the child class with the same name as the method you want to override in the parent class. Python will disregard the parent class method and only pay attention to the method you define in the child class.
    
    ```
    class ElectricCar(Car):
    --snip--
    
    def fill_gas_tank(self):
      """Electric cars don't have gas tanks."""
      print("This car doesn't have a gas tank!")
    ```

+ Instances as Attributes

    You can break your large class into smaller classes that work together; this approach is called composition.
    
    we can move those attributes and methods to a separate class called Battery. Then we can use a Battery instance as an attribute in the ElectricCar class:
    
    ```{python}
    class Battery:
      """A simple attempt to model a battery for an electric car."""
      
      def __init__(self, battery_size=40):
        """Initialize the battery's attributes."""
        self.battery_size = battery_size

      def describe_battery(self):
        """Print a statement describing the battery size."""
        print(f"This car has a {self.battery_size}-kWh battery.")
        
      def get_range(self):
        """Print a statement about the range this battery provides."""
        if self.battery_size == 40:
          range = 150
        elif self.battery_size == 65:
          range = 225

        print(f"This car can go about {range} miles on a full charge.")

    class ElectricCar(Car):
      """Represent aspects of a car, specific to electric vehicles."""

      def __init__(self, make, model, year):
        """
        Initialize attributes of the parent class.
        Then initialize attributes specific to an electric car.
        """

        super().__init__(make, model, year)
        self.battery = Battery()
    
    my_leaf = ElectricCar('nissan', 'leaf', 2024)
    print(my_leaf.get_descriptive_name())
    my_leaf.battery.describe_battery()
    my_leaf.battery.get_range()
    ```
    
+ Importing Classes

+ Importing a Single Class

    ```
    from car import Car
    
    my_new_car = Car('audi', 'a4', 2024)
    ```

+ Storing Multiple Classes in a Module

    You can store as many classes as you need in a single module, although each class in a module should be related somehow. The classes Battery and ElectricCar both help represent cars, so let’s add them to the module car.py.
    
    Now we can make a new file called my_electric_car.py, import the ElectricCar class, and make an electric car:
    
    ```
    from car import ElectricCar
    
    my_leaf = ElectricCar('nissan', 'leaf', 2024)
    ```
    
+ Importing Multiple Classes from a Module

    ```
    from car import Car, ElectricCar
    
    my_mustang = Car('ford', 'mustang', 2024)
    my_leaf = ElectricCar('nissan', 'leaf', 2024)
    ```

+ Importing an Entire Module

    ```
    import car
    
    my_mustang = car.Car('ford', 'mustang', 2024)
    my_leaf = car.ElectricCar('nissan', 'leaf', 2024)
    ```
    
+ Importing All Classes from a Module

    This method is not recommended for two reasons. First, it’s helpful to be able to read the import statements at the top of a file and get a clear sense of which classes a program uses. With this approach it’s unclear which classes you’re using from the module. This approach can also lead to confusion with names in the file. If you accidentally import a class with the same name as something else in your program file, you can create errors that are hard to diagnose.
    
    ```
    from module_name import *
    ```

+ Importing a Module into a Module

    ```
    electric_car.py
    
    from car import Car
    
    car.py
    
    my_cars.py
    
    from car import Car
    from electric_car import ElectricCar
    
    my_mustang = Car('ford', 'mustang', 2024)
    my_leaf = ElectricCar('nissan', 'leaf', 2024)
    ```
    
+ Using Aliases

    ```
    from electric_car import ElectricCar as EC
    
    my_leaf = EC('nissan', 'leaf', 2024)
    ```
    
    You can also give a module an alias. Here’s how to import the entire electric_car module using an alias:
    
    ```
    import electric_car as ec
    
    my_leaf = ec.ElectricCar('nissan', 'leaf', 2024)
    ```

+ The Python Standard Library

    ```
    from random import randint
    randint(1, 6)}
    ```

# FILES AND EXCEPTIONS